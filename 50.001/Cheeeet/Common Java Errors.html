<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>

<style type="text/css">
    code, pre { font-size: 120%; }
</style>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>CS 111: Common Java Errors</title>

</head>
<body>

<center><font face="arial"><font size="6" color="firebrick"><b>CS 111: Common Java Errors</b></font><br>
<!--<b><font size="4">Expressions, types, and variables</font></b> </font>--></font></center><font face="arial">
<p></p>
<font face="arial">
<dl>
<p>
</p><dd>
<b>List of common Java error messages:</b>
    <ol>
    </li><li><a href="#symbol">cannot find symbol</a>
    </li><li><a href="#declare">class &lt;X> is public, should be declared in a file named &lt;X>.java</a>
    <li><a href="#class">class, interface, or enum expected</a>
    <li><a href="#expected">&lt;X> expected</a>
    </li><li><a href="#identifier">&lt;identifier> expected</a>
    </li><li><a href="#illegalExp">illegal start of expression</a>
	</li><li><a href="#incompatible">incompatible types</a>
    </li><li><a href="#retType">invalid method declaration; return type required</a>
	</li><li><a href="#arrayIndex">java.lang.ArrayIndexOutOfBoundsException: &lt;X></a>
	</li><li><a href="#stringIndex">java.lang.StringIndexOutOfBoundsException: String index out of range: &ltX></a>
	</li><li><a href="#method">method &lt;X> in class &lt;Y> cannot be applied to given types</a>
	</li><li><a href="#missingRet">missing return statement</a>
    </li><li><a href="#precision">possible loss of precision</a>
	</li><li><a href="#EOF">reached end of file while parsing</a>
	</li><li><a href="#unreachable">unreachable statement</a>
    </li><li><a href="#initialized">variable might not have been initialized</a>
    </li></ol>
<p>


Encountering an error that you don't see above? Ask
on <a href="https://www.piazza.com/">Piazza</a> -- using the 
<i>error</i> folder.
</p><p>

</p><ol>

<a name="symbol">
</a></p></li><li><a name="symbol"><strong>cannot find symbol</strong> <br><br>
"Cannot find symbol" errors generally occur when you try to
reference an undeclared variable in your code. Consider the following
example:

<pre>    public class Test {
        public static void main(String[] args) {
            int a = 3;
            int b = 4;
            int c = 20;
        
            average = (a + b + c)/5.0;
            System.out.println(average);
        }
    }

	<font color="FF0000">
    1 error found:
    File: Test.java  [line: 7]
    Error: Test.java:7: cannot find symbol
    symbol  : variable average
    location: class Test
	</font>
</pre>

Here, the variable <tt><font size="4">average</font></tt> has not
been declared-- you need to tell the compiler what the type of 
average is; for example:

<pre>    <span style="BACKGROUND-COLOR: #ffff00">double</span> average = (a + b + c)/5.0;
</pre>

Secondly, sometimes this error occurs because you are trying to reference a
method in your code, but forget to include the parentheses that
indicate a reference to a method, even when there are no parameters.
For example:

<pre>    public class Test {
        public static void main(String[] args) {
            my_method;
        }
    
        public static void my_method() {
            System.out.println("Hello, world!");
        }
    }

    <font color="FF0000">
    1 error found:
    File: Test.java  [line: 7]
    Error: Test.java:7: cannot find symbol
    symbol  : variable my_method
    location: class Test
	</font>
</pre>

Here, the compiler is looking for a <i>variable</i> called 
<tt><font size="4">my_method</font></tt> in the
<tt><font size="4">main</font></tt> method; instead, you want
to initiate a <i>method call</i> to
<tt><font size="4">my_method</font></tt>:

<pre>    public class Test {
        public static void main(String[] args) {
            my_method<span style="BACKGROUND-COLOR: #ffff00">()</span>;
        }
    
        public static void my_method() {
            System.out.println("Hello, world!");
        }
    }
</pre>

Thirdly, this error could also occur if you forget to import a Java package that you need to use.
For example, consider the following program that reads in an integer from the user:

<pre>    public class Test {     
        public static void main(String[] args) {
            Scanner console = new Scanner(System.in);
            int n = console.nextInt();
        }
    }

    <font color="FF0000">
    2 errors found:
    File: Test.java  [line: 3]
    Error: cannot find symbol
      symbol:   class Scanner
      location: class Test
    File: Test.java  [line: 3]
    Error: cannot find symbol
      symbol:   class Scanner
      location: class Test
	</font>
</pre>
The issue here is that the program must import <tt><font size="4">java.util.Scanner</font></tt> (or, more generally, <tt><font size="4">java.util.*</font></tt>). Otherwise, the compiler does not know
what a <tt><font size="4">Scanner</font></tt> type is. You may encounter a similar error if you
forget to import <tt><font size="4">java.util.Arrays</font></tt> or <tt><font size="4">java.io.*</font></tt> when working with file input/output. To fix the code above:

<pre>    import java.util.*; // or --> import java.util.Scanner;    
    public class Test {     
        public static void main(String[] args) {
            Scanner console = new Scanner(System.in);
            int n = console.nextInt();
        }
    }
</pre>

Finally, this error can occur if you have case-sensitive errors with variables. All identifiers in
Java are case sensitive. This means that if you declare a variable named <tt><font size="4">average</font></tt> and try to later refer to it using <tt><font size="4">Average</font></tt>, the compiler
will complain that it cannot find a symbol named <tt><font size="4">Average</font></tt>.


</a><p><a name="symbol">

</a><a name="declare">
</a></p></li><li><a name="declare"><strong>class &lt;X> is public, should be declared in a file named &lt;X>.java</strong> <br><br>
This error occurs when the <i>class name</i> and the <i>filename</i> of a given Java program do
not match. For example, say that the following program is saved in a file named Foo.java:

<pre>    public class Bar {     
        public static void main(String[] args) {
            System.out.println("Hello, world!");
        }
    }

	<font color="FF0000">
    1 error found:
    File: Foo.java  [line: 1]
    Error: class Bar is public, should be declared in a file named Bar.java
	</font>
</pre>

Since Foo does not match with Bar, the code will not compile. To fix this error, either rename
the file or change the class name.
</pre>
</a><p><a name="declare">

</a><a name="class">
</a></p></li><li><a name="class"><strong>class, interface, or enum expected</strong> <br><br>
This error is another form of problems with curly braces. Typically this error arises when there
are too many curly braces at the end of a program; for example:

<pre>    public class Test {     
        public static void main(String[] args) {
            System.out.println("Hello!");
        }
    }
    }

	<font color="FF0000">
    1 error found:
    File: Test.java  [line: 6]
    Error: class, interface, or enum expected
	</font>
</pre>

One way of figuring out where this error is occurring (as with all problems with curly braces) is
to correctly indent the code. Again, one way of doing this in Dr. Java is to press CTRL-A (to
highlight the entire program) and then TAB (to correctly indent the highlighted code). In our
example program above, notice that the two curly braces at the end of the program are at the same
indentation level, which cannot happen in a valid program. Therefore, simply delete one of the
curly braces for the code to compile:

<pre>    public class Test {     
        public static void main(String[] args) {
            System.out.println("Hello!");
        }
    }
</pre>
</a><p><a name="class">

</a><a name="expected">
</a><li><a name="expected"><strong>&lt;X> expected</strong> <br><br>
Errors of the form "&lt;X> expected" happen when the compiler
detects a missing character in your code. The error message will 
tell you which character is missing and on which line. Consider
the following program:

<pre>    public class Test
        public static void main(String[] args) {
            my_method();
        }
    
        public static void my_method() {
            System.out.println("Hello, world!")     
        }
    }
	
    <font color="FF0000">
    2 errors found:
    File: Test.java  [line: 1]
    Error: Test.java:1: '{' expected
    File:.java  [line: 7]
    Error: Test.java:7: ';' expected
	</font>
</pre>

These error messages tell you there is a missing curly brace
on the first line and a missing semi-colon on the seventh line.
To fix this kind of error, simply place the missing
character in the correct position in the code:

<pre>    public class Test <span style="BACKGROUND-COLOR: #ffff00">{</span>
        public static void main(String[] args) {
            my_method();
        }
    
        public static void my_method() {
            System.out.println("Hello, world!")<span style="BACKGROUND-COLOR: #ffff00">;</span>   
        }
    }
</pre><a name="expected">
</a><a name="identifier">
</a></p></li><li><a name="identifier"><strong>&lt;identifier> expected</strong> <br><br>
This error occurs when code is written outside of a method; it is typically caused by
a mistake in curly braces. Consider the following example:

<pre>    public class Test { 
        System.out.println("Hello!");
    
        public static void main(String[] args) {
            System.out.println("World!");
        }
    }

 <font color="FF0000">
    2 errors found:
    File: Test.java  [line: 2]
    Error: &lt;identifier> expected
    File: Test.java  [line: 2]
    Error: illegal start of type
	</font>
</pre>

In this case, it is somewhat clear that the first print statement must be inside the
<tt><font size="4">main</font></tt> method for the code to compile. However, when there
is more than one method and a curly brace error, the "&lt;identifier> expected" error
can be harder to see:
    
<pre>    public class Test {     
        public static void main(String[] args) {
            System.out.println("Hello!");}
            System.out.println("World!");
        }
    }

 <font color="FF0000">
    3 errors found:
    File: Test.java  [line: 4]
    Error: &lt;identifier> expected
    File: Test.java  [line: 4]
    Error: illegal start of type
    File: Test.java  [line: 6]
    Error: class, interface, or enum expected
	</font>
</pre>

There is an extra curly brace in the code above, but the code is not properly indented
so it is difficult to see. The effect of this is to end the <tt><font size="4">main</font></tt>
method immediately after the line that prints "<tt><font size="4">Hello!</font></tt>," which
leaves the print statement that prints "<tt><font size="4">World!</font></tt>" outside of any
method. To fix the error above, simply remove the curly brace at the end of the third line:

<pre>    public class Test {     
        public static void main(String[] args) {
            System.out.println("Hello!");
            System.out.println("World!");
        }
    }

</pre>
</a><p><a name="identifier">

</a><a name="illegalExp">
</a></p></li><li><a name="illegalExp"><strong>illegal start of expression</strong> <br><br>
An "illegal start of expression" error occurs when the
compiler encounters an inappropriate statement in the code.
Consider the following example:

<pre>    public class Test {
        public static void main(String[] args) {
            my_method();
    
    
        public static void my_method() {
            System.out.println("Hello, world!");
        }
    } 

    <font color="FF0000">
    5 errors found:
    File: Test.java  [line: 6]
    Error: Test.java:6: illegal start of expression
    File: Test.java  [line: 6]
    Error: Test.java:6: illegal start of expression
    File: Test.java  [line: 6]
    Error: Test.java:6: ';' expected
    File: Test.java  [line: 6]
    Error: Test.java:6: ';' expected
    File: Test.java  [line: 9]
    Error: Test.java:9: reached end of file while parsing
	</font>
</pre>

Here, there is a missing closing curly brace for the 
<tt><font size="4">main</font></tt> method. Since the main 
method is not closed, the compiler is expecting the line
after the call to <tt><font size="4">my_method</font></tt>
to be a part of the <tt><font size="4">main</font></tt>
method's code. However, it instead encounters
<tt><font size="4">public static void my_method() {</font></tt>, 
which is not a valid statement inside a method.
<p>
The "illegal start of expression" error message is
not as helpful as the "... expected" error message
that we encountered above. For this error (and for many other
errors), it may be necessary to look at the lines that come
before the error to see where the problem is. In this case, we
simply need to add a curly brace to close the <tt><font size="4">main</font></tt>
method on the line before where the compiler issued the warning.
After recompiling, all of the errors are resolved. 

</p><pre>    public class Test {
        public static void main(String[] args) {
            my_method();
        <span style="BACKGROUND-COLOR: #ffff00">}</span>   
    
        public static void my_method() {
            System.out.println("Hello, world!");
        }
    } 
</pre>

For "illegal start of expression" errors, try looking at
the lines preceding the error for a missing <tt><font size="4">')'</font></tt>
or <tt><font size="4">'}'</font></tt>.
</a><p><a name="illegalExp">

</a><a name="incompatible">
</a></p></li><li><a name="incompatible"><strong>incompatible types</strong> <br><br>
This error occurs when there are type issues with your program.
It is possible to convert between some kinds of types; for example,
you can freely convert a <tt><font size="4">char</font></tt> to an
<tt><font size="4">int</font></tt> and vice versa, and you can also
convert a <tt><font size="4">double</font></tt> to an
<tt><font size="4">int</font></tt> with some typecasting. However,
you can <i>not</i> convert between primitive types and objects
such as <tt><font size="4">String</font></tt>. For example:

<pre>    public class Test {
        public static void main(String[] args) {
            int num = "Hello, world!";
        }
    }

    <font color="FF0000">
    1 error found:
    File: Test.java  [line: 3]
    Error: Test.java:3: incompatible types
    found   : java.lang.String
    required: int
	</font>
</pre>

Typically, you cannot "fix" this error as you can for most other
errors. This is not a syntax error, but rather an error in type
logic. It usually does not make sense to try to put a
<tt><font size="4">String</font></tt> into an integer type.
However, there are some applications where you need to do
something like a <tt><font size="4">String</font></tt> to
<tt><font size="4">int</font></tt> conversion, such as when the
<tt><font size="4">String</font></tt> is a representation of a
number:

<pre>    public class Test {
        public static void main(String[] args) {
            int num = "500";
        }
    }
	
    <font color="FF0000">
    1 error found:
    File: Test.java  [line: 3]
    Error: Test.java:3: incompatible types
    found   : java.lang.String
    required: int
	</font>
</pre>

To fix something like this, you might be able to depend on Java
classes such as the <tt><font size="4">Integer</font></tt> class,
which is capable of taking a <tt><font size="4">String</font></tt>
that represents a number and converting it to an integer type:

<pre>    public class Test {
        public static void main(String[] args) {
            int num = Integer.parseInt("500");
        }
    }
</pre>

However, this kind of solution to an "incompatible types"
error is the exception and not the rule, as this error usually
comes from a mistake in logic.
</a><p><a name="incompatible">

</a><a name="retType">
</a></p></li><li><a name="retType"><strong>invalid method declaration; return type required</strong> <br><br>
Every method in Java requires that you explicitly state the
return type of the method. Even methods that do not return a
value must explicitly say <tt><font size="4">void</font></tt>
in the method signature, just as the <tt><font size="4">main</font></tt>
method does.
<p>
When a method declaration does not contain a return type, this
error will occur:

</p><pre>    public class Test {
        public static void main(String[] args) {
            int x = getValue();
            System.out.println(x);
        }
    
        public static getValue() {
            return 10;
        }
    }

	<font color="FF0000">
    1 error found:
    File: Test.java  [line: 7]
    Error: Test.java:7: invalid method declaration; return type required
	</font>
</pre>

To fix this, simply insert the appropriate return type in the method
signature:

<pre>    public class Test {
        public static void main(String[] args) {
            int x = getValue();
            System.out.println(x);
        }
    
        public static <span style="BACKGROUND-COLOR: #ffff00">int</span> getValue() {
            return 10;
        }
    }
</pre>
</a><p><a name="retType">

</a><a name="arrayIndex">
</a></p></li><li><a name="arrayIndex"><strong>java.lang.ArrayIndexOutOfBoundsException: &lt;X></strong> <br><br>
An <tt><font size="4">ArrayIndexOutOfBoundsException</font></tt> is
thrown when an attempt is made to access an index in an array that is not valid. The only
valid indices for an array <tt><font size="4">arr</font></tt> are in the
range [0, <tt><font size="4">arr.length - 1</font></tt>]; any attempt
to access an index outside of this range will result in this error. For
example:

<pre>    public class Test {
        public static void main(String[] args) {
            int[] arr = {1, 2, 3};
            for (int i = 0; i <= arr.length; i++) {
                System.out.println(arr[i]);
            }
        }
    }
	
    <font color="FF0000">
    java.lang.ArrayIndexOutOfBoundsException: 3
	at Test.main(Test.java:5)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at edu.rice.cs.drjava.model.compiler.JavacCompiler.runCommand(JavacCompiler.java:272)
	</font>
</pre>

This error is quite similar to the <a href="#stringIndex">java.lang.StringIndexOutOfBoundsException: String index out of range: &lt;X></a> error that we have previously discussed. The error message for this kind of error is similarly irrelevant toward the end of the message. However, the first line lets you know that a problem with an array index was encountered, and the
index in error was 3, in this case. The next line tells you that it encountered this
error on line 5 of Test.java, inside the <tt><font size="4">main</font></tt> method.
<p>
In this case, the error occurred because the <tt><font size="4">for</font></tt> loop iterates
too many times; the value of the loop index, <tt><font size="4">i</font></tt>, reaches 4 and is
therefore out of bounds. Instead, the upper bound should use the <tt><font size="4"><</font></tt> boolean operator, or an equivalent statement.

<pre>    public class Test {
        public static void main(String[] args) {
            int[] arr = {1, 2, 3};
            for (int i = 0; i <span style="BACKGROUND-COLOR: #ffff00"><</span> arr.length; i++) {
                System.out.println(arr[i]);
            }
        }
    }
</pre>

When dealing with an <tt><font size="4">ArrayIndexOutOfBoundsException</font></tt>, it is usually helpful to print out the value of the index variable that is accessing the
array and try to trace through to code to find out why it is reaching that (invalid) value.
</p><p>

</p></a></li><a name="arrayIndex">

</a><a name="stringIndex">
</a></p></li><li><a name="stringIndex"><strong>java.lang.StringIndexOutOfBoundsException: String index out of range: v</strong> <br><br>
A <tt><font size="4">StringIndexOutOfBoundsException</font></tt> is
thrown when an attempt is made to access an index in the
<tt><font size="4">String</font></tt> that is not valid. The only
valid indices for a <tt><font size="4">String str</font></tt> are in the
range [0, <tt><font size="4">str.length() - 1</font></tt>]; any attempt
to access an index outside of this range will result in this error. For
example:

<pre>    public class Test {
        public static void main(String[] args) {
            String str = "Hello, world!";

            String a = str.substring(-1, 3);
            String b = str.charAt(str.length());
            String c = str.substring(0, 20);
        }
    }
	
    <font color="FF0000">
    java.lang.StringIndexOutOfBoundsException: String index out of range: -1
        at java.lang.String.substring(Unknown Source)
        at Test.main(Test.java:5)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
        at java.lang.reflect.Method.invoke(Unknown Source)
        at edu.rice.cs.drjava.model.compiler.JavacCompiler.runCommand(JavacCompiler.java:271)
	</font>
</pre>

The error message for this kind of error becomes less relevant towards
the end. However, the first line lets you know that a problem with a
<tt><font size="4">String</font></tt> index was encountered, and the
index in error was -1. The next line tells you that it encountered this
error while trying to perform the <tt><font size="4">substring</font></tt>
routine, which was called from the <tt><font size="4">Test</font></tt>
class on line 5. This "backtrace" of the error tells you the line numbers
of the method calls involved so that you can trace your error to the source
and correct it.
<p>
Note that <i>all</i> of 
<tt><font size="4">a</font></tt>, <tt><font size="4">b</font></tt>,
and <tt><font size="4">c</font></tt> would have thrown this error, but
the program was halted after the first occurred.
</p><p>
This is not a compile-time error, but rather a <i>runtime</i> error. In
other words, the compiler will accept this kind of error because it is
a logical error. Additionally, it may not be known before the program
is run that the error will occur. To fix this error, you often have
to correct the logic of your program to ensure that the program will
not try to access an invalid index.
</p><p>

</p></a></li><a name="stringIndex">

</a><a name="method">
</a></p></li><li><a name="method"><strong>method &lt;X> in class &lt;Y> cannot be applied to given types</strong> <br><br>
This method occurs when you try to call a method using the wrong number or wrong order of parameters.
For example, consider the following program:
<pre>    public class Test {     
        public static void main(String[] args) {
            myMethod(1.0, 2, "Hello!");
        }
    
        public static void myMethod(double d, String s, int x) {
            System.out.println(s + " " + d + " " + x);
        }
    }
    
	<font color="FF0000">
    1 error found:
    File: Test.java  [line: 3]
    Error: method myMethod in class Test cannot be applied to given types;
      required: double,java.lang.String,int
      found: double,int,java.lang.String
      reason: actual argument int cannot be converted to java.lang.String by method invocation conversion
	</font>
</pre>

The error message for this error is very helpful. The line that says "required" tells you about what
the method is expecting. It lists the order of the arguments that are required. In the example above,
the parameters for <tt><font size="4">myMethod</font></tt> should be a <tt><font size="4">double</font></tt>, then a <tt><font size="4">String</font></tt>, and then an <tt><font size="4">int</font></tt>.
<p>
The next line of the error message (which says "found") tells you what you (incorrectly) tried to
use to call the method. In this example, we invoked the method using a <tt><font size="4">double</font></tt>, then an <tt><font size="4">int</font></tt>, and then a <tt><font size="4">String</font></tt>-- which is the wrong order!
<p>
We can fix this by ensuring that the number and ordering of the method parameters is correct:

</p><pre>    public class Test {     
        public static void main(String[] args) {
            <span style="BACKGROUND-COLOR: #ffff00">myMethod(1.0, "Hello!", 2);</span>
        }
    
        public static void myMethod(double d, String s, int x) {
            System.out.println(s + " " + d + " " + x);
        }
    }
</pre>
</a><p><a name="method">

</a><a name="missingRet">
</a></p></li><li><a name="missingRet"><strong>missing return statement</strong> <br><br>
This method happens when you declare that a method will return
a value, but then fail to actually return the value. For example:

<pre>    public class Test {
        public static void main(String[] args) {
            int x = twice(5);
            System.out.println(x);
        }
    
        public static int twice(int x) {
            int value = 2 * x;
        }
    }
	
    <font color="FF0000">	
    1 error found:
    File: Test.java  [line: 9]
    Error: Test.java:9: missing return statement
	</font>
</pre>

We have informed the compiler that the <tt><font size="4">twice</font></tt>
method will return an <tt><font size="4">int</font></tt>, but
we are missing the return statement:

<pre>    public class Test {
        public static void main(String[] args) {
            int x = twice(5);
            System.out.println(x);
        }
    
        public static int twice(int x) {
            int value = 2 * x;
            <span style="BACKGROUND-COLOR: #ffff00">return value;</span>
        }
    }
</pre>

Returning values in <tt><font size="4">if</font></tt> statements
can also trick the compiler into thinking that it's possible
no value will be returned, as in the following example:

<pre>    public class Test {
        public static void main(String[] args) {
            int x = absVal(-5);
            System.out.println(x);
        }
    
        public static int absVal(int x) {
            if (x &lt; 0) {
                return -x;
            }
			
            if (x &gt;= 0) {
                return x;
            }
        }
    }
	
    <font color="FF0000">	
    1 error found:
    File: Test.java  [line: 15]
    Error: Test.java:15: missing return statement
	</font>
</pre>

To avoid this, we can either use an <tt><font size="4">else</font></tt>
statement (as we did in the </a><a href="#initialized">Variable might not
have been initialized example</a>), or we can
simply not use the second <tt><font size="4">if</font></tt> statement
because we know that if we've reached that point in the method we
can just return <tt><font size="4">x</font></tt>:

<pre>    public class Test {
        public static void main(String[] args) {
            int x = absVal(-5);
            System.out.println(x);
        }
    
        public static int absVal(int x) {
            if (x &lt; 0) {
                return -x;
            }
			
            <span style="BACKGROUND-COLOR: #ffff00">return x;</span>
        }
    }
</pre>
<p><a name="missingRet">

</a><a name="precision">
</a></p></li><li><a name="precision"><strong>possible loss of precision</strong> <br><br>
A "possible loss of precision" error occurs when you attempt
to store more information in a variable than it can hold. The most
common example of this error is trying to assign a
<tt><font size="4">double</font></tt> to an <tt><font size="4">int</font></tt>:

<pre>    public class Test {
        public static void main(String[] args) {
            int pi = 3.14159;
            System.out.println("The value of pi is: " + pi);
        }
    }
	
    <font color="FF0000">
    1 error found:
    File: Test.java  [line: 3]
    Error: Test.java:3: possible loss of precision
    found   : double
    required: int
	</font>
</pre>

This error happens because the amount of space that a computer
needs to store a <tt><font size="4">double</font></tt> is
typically <i>twice</i> as much as the space needed to store an
<tt><font size="4">int</font></tt>. You're allowed to do this
by acknowledging to the compiler that you know that you're going
to lose precision if you do the assignment. To acknowledge this,
you can use a typecast:

<pre>    public class Test {
        public static void main(String[] args) {
            int pi = <span style="BACKGROUND-COLOR: #ffff00">(int)</span>3.14159;
            System.out.println("The value of pi is: " + pi);
        }
    }
</pre>

Now the compiler does not complain, but the 
<tt><font size="4">pi</font></tt> variable only contains the
value <tt><font size="4">3</font></tt> due to integer rounding.
</a><p><a name="precision">

</a><a name="EOF">
</a></p></li><li><a name="EOF"><strong>reached end of file while parsing</strong> <br><br>
This error typically happens when you are not adequately closing
your program using curly braces. The error message is essentially
saying that the compiler has reached the end of the file without any
acknowledgement that the file has ended. For example:

<pre>    public class Test {
        public static void main(String[] args) {
            my_method();
        }
    
        public static void my_method() {
            System.out.println("Hello, world!");
        }

	<font color="FF0000">
    1 error found:
    File: Test.java  [line: 9]
    Error: Test.java:9: reached end of file while parsing
	</font>
</pre>

To fix this, all you have to do is correct your ending curly
braces (<tt><font size="4">'}'</font></tt>). Sometimes all
you need is a curly brace at the end of your file; other times
you may have missed a curly brace or added an extra curly brace
in the middle of your code.
<p>
One way to diagnose where the problem is occuring is to use the
<tt><font size="4">CTRL-A + TAB</font></tt> shortcut to attempt
to properly indent your code. Since we have a curly brace problem,
however, the code will not be properly indented. Search for the
place in the file where the indentation first becomes incorrect.
This is where your error is happening!
</p><p>
Once the curly braces in the program match up appropriately,
the compiler will not complain:

</p><pre>    public class Test {
        public static void main(String[] args) {
            my_method();
        }
    
        public static void my_method() {
            System.out.println("Hello, world!");
        }
    <span style="BACKGROUND-COLOR: #ffff00">}</span>
</pre>
</a><p><a name="EOF">

</a><a name="unreachable">
</a></p></li><li><a name="unreachable"><strong>unreachable statement</strong> <br><br>
An "unreachable statement" error occurs when the compiler detects
that it is impossible to reach a given statement during the flow
of a program. This error is often caused by placing statements
after <tt><font size="4">return</font></tt> or <tt><font size="4">break</font></tt>.
For example:

<pre>    public class Test {
        public static void main(String[] args) {
            int value = twice(5);
            System.out.println(value);
        }
    
        public static int twice(int x) {
            int twice = 2 * x;
            return twice;
            System.out.println("Returning " + twice);
        }
    }
	<font color="FF0000">
    2 errors found:
    File: Test.java  [line: 10]
    Error: Test.java:10: unreachable statement
    File: Test.java  [line: 11]
    Error: Test.java:11: missing return statement
	</font>
</pre>

The compiler gives two errors: one to indicate that the line
<tt><font size="4">System.out.println("Returning " + twice);</font></tt>
is an unreachable statement, and another because it assumes
that if we <i>can</i> get to that print statement, then we
would need a <tt><font size="4">return</font></tt> statement
somewhere after it.
<p>
We can fix this by placing the print statement before the
<tt><font size="4">return</font></tt> so it can be executed:

</p><pre>    public class Test {
        public static void main(String[] args) {
            int value = twice(5);
            System.out.println(value);
        }
    
        public static int twice(int x) {
            int twice = 2 * x;
            <span style="BACKGROUND-COLOR: #ffff00">System.out.println("Returning " + twice);</span>
            return twice;
        }
    }
</pre>
</a><p><a name="unreachable">

</a><a name="initialized">
</a></p></li><li><a name="initialized"><strong>variable might not have been initialized</strong> <br><br>
This error occurs when the compiler believes you're trying
to use a variable that has not been "initialized"--
or given an initial value-- yet. In a very simple case:

<pre>    public class Test {
        public static void main(String[] args) {
            int x = 2;
            int y;
            System.out.println(x + y);
        }
    } 

    <font color="FF0000">
    1 error found:
    File: Test.java  [line: 5]
    Error: Test.java:5: variable y might not have been initialized
	</font>
</pre>

Here, you have not told the compiler what the value of
<tt><font size="4">y</font></tt> is. Therefore,
<tt><font size="4">y</font></tt> cannot be printed; it needs to be
initialized as <tt><font size="4">x</font></tt> is in this example.
<p>
In more complicated scenarios, <tt><font size="4">if</font></tt>
statements can cause this error if you are not careful about
ensuring that a variable is initialized. For example:

</p><pre>    public class Test {
        public static void main(String[] args) {
            int x;
            boolean setX = false;
			
            if (setX) {
                x = 10;
            }
			
            System.out.println(x);
        }
    }

    <font color="FF0000">
    1 error found:
    File: Test.java  [line: 8] 
    Error: Test.java:8: variable x might not have been initialized
	</font>
</pre>

Here again it is clear that the variable <tt><font size="4">x</font></tt>
will not be initialized, and therefore an error occurs. However, cases can
also arise where it is clear to us that one of the cases <i>has</i> to be
reached and therefore the error should not happen. However, the compiler is
not always smart enough to see cases that we as humans can see. For example:

<pre>    public class Test {
        public static void main(String[] args) {
            int x;
            boolean setToTen = false;
         
            if (setToTen) {
                x = 10;
            }
        
            if (!setToTen) {
                x = 0;
            }
        
            System.out.println(x);
        }
    }

    <font color="FF0000">
    1 error found:
    File: Test.java  [line: 14]
    Error: Test.java:14: variable x might not have been initialized
	</font>
</pre>

It may appear obvious that <tt><font size="4">x</font></tt> will get set
to a value one way or another, but the compiler cannot see this. One way
to fix this error is to use an <tt><font size="4">else</font></tt> statement.
When using an <tt><font size="4">else</font></tt> statement, the compiler
<i>is</i> smart enough to see that in at least one case
<tt><font size="4">x</font></tt> will be initialized:

<pre>    public class Test {
        public static void main(String[] args) {
            int x;
            boolean setToTen = false;
        
            if (setToTen) {
                x = 10;
            } <span style="BACKGROUND-COLOR: #ffff00">else {</span>
            <span style="BACKGROUND-COLOR: #ffff00">    x = 0;</span>
            <span style="BACKGROUND-COLOR: #ffff00">}</span>
        
            System.out.println(x);
        }
    }
</pre>
</a><p><a name="initialized"></li></ol>
<p>
<i>Original document created by Cody Doucette '14.</i>



</p></a></dd></dl></font></font></body></html>
